 使用广度优先搜索算法遍历迷宫

#include <bits/stdc++.h>
#include <algorithm>
#include <cstring>

using namespace std;

int mp[30][50];
int dir[4][2] = {{1,0},{0,-1},{0,1},{-1,0}};
char dirc[4] = {'D','L','R','U'};
bool vis[30][50];

int n;   矩阵的行数
int m;   矩阵的列数

struct node{
    int x;
    int y;
    int step;
    string str;

    node(int xx, int yy, int ss, string s){ x = xx; y = yy; s = ss; str = s; }
};

queue<node> q;

bool visited(int x, int y)
{
    if(x < 0 || x > n || y < 0 || y > m || vis[x][y] == true)    return true;
    else return false;
}

void bfs(int x, int y)
{
    q.push(node(x,y,0,""));
    vis[x][y] = true;

    while(!q.empty())
    {
        node now = q.front();

        if(now.x == n - 1 && now.y == m - 1)
        {
             已经找到终点
            cout << now.str << endl;
            cout << now.step << endl;
        }

        q.pop();

        for(int i = 0; i < 4; ++ i )
        {
            int nx = now.x + dir[i][0];
            int ny = now.y + dir[0][i];
            if(!visited(nx,ny))
            {
                q.push(node(nx, ny, now.step + 1, now.str + dirc[i]));
                vis[nx][ny] = true;
            }
        }
    }
}

int main()
{
    n = 30;
    m = 50;
    for(int i = 0; i < n; ++i){
        for(int j = 0; j < m; ++j){
            scanf("%d",&mp[i][j]);
        }
    }
    bfs(0,0);
    system("pause");
    return 0;
}

/*
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
*/

